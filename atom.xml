<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Pancras Home</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-04-08T06:02:23.319Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Pancras</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java基础</title>
    <link href="http://example.com/2023/04/06/Java%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/2023/04/06/Java%E5%9F%BA%E7%A1%80/</id>
    <published>2023-04-06T03:00:18.000Z</published>
    <updated>2023-04-08T06:02:23.319Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、final关键字"><a href="#1、final关键字" class="headerlink" title="1、final关键字"></a>1、final关键字</h4><ul><li><p>final声明的变量</p><p>使用final关键字修饰一个变量时，是指引用变量不能变，引用变量所指向的对象中的内容还是可以改变的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> StringBuilder sb=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">sb=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;def&quot;</span>); <span class="comment">//这是不允许的</span></span><br><span class="line"></span><br><span class="line">sb.append(<span class="string">&quot;def&quot;</span>); <span class="comment">//这是可以的</span></span><br></pre></td></tr></table></figure></li><li><p>final声明的方法</p><p>final 也可以声明方法，Java 里用 final 修饰符去修饰一个方法的唯一正确用途就是表达：这个方法原本是一个虚方法，现在通过 final 来声明这个方法不允许在派生类中进一步被覆写（Override）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Reader</span> <span class="keyword">extends</span> <span class="title class_">User</span>&#123;</span><br><span class="line">    <span class="comment">//以下操作是不被允许的</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;def&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>final声明的类</p><p>final 修饰的类不能被继承，Java 中有许多类是 final 的，比如 String, Integer 以及其他包装类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承将不被允许</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Reader</span> <span class="keyword">extends</span> <span class="title class_">User</span>&#123;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="2、-和equals的区别"><a href="#2、-和equals的区别" class="headerlink" title="2、==和equals的区别"></a>2、==和equals的区别</h4><ul><li><p>==操作符在对基本数据类型进行比较时，比较的是值内容是否相等。对引用类型进行比较时，比较的是变量中存储的内存地址是否相等。</p></li><li><p>equals方法是用于比较两个独立对象的内容是否相同，如果未重写，即采用Object的equals方法，则还是对地址进行比较。</p><p>如下图所示，对于引用类型，equals比较的是内容，==比较的是地址。</p><p><img src="https://img-1309553126.cos.ap-beijing.myqcloud.com/blog_imgs/image-20230406202606985.webp" alt="image-20230406202606985"></p></li></ul><h4 id="3、Overload（重载）和Override（重写）的区别"><a href="#3、Overload（重载）和Override（重写）的区别" class="headerlink" title="3、Overload（重载）和Override（重写）的区别"></a>3、Overload（重载）和Override（重写）的区别</h4><ul><li>重载表示同一个类中可以有多个名称相同的方法，但这些方法的参数列表各不相同（即参数个数或类型不同）。注意，如果两个方法的参数列表完全相同，<strong>不能</strong>通过让返回值不同来实现重载。</li><li>重写表示子类中的方法可以与父类中的某个方法的名称和参数完全相同，通过子类创建的实例对象调用这个方法时，将调用子类中的定义方法，这相当于把父类中定义的那个完全相同的方法给覆盖了，这也是面向对象编程的多态性的一种表现。<strong>子类覆盖父类的方法时，只能比父类抛出更少的异常，或者是抛出父类抛出的异常的子异常</strong>，因为子类可以解决父类的一些问题，不能比父类有更多的问题。子类方法的访问权限只能比父类的更大，不能更小。如果父类的方法是private类型，那么，子类则不存在覆盖的限制，相当于子类中增加了一个全新的方法。</li></ul><h4 id="4、抽象类和接口有什么区别"><a href="#4、抽象类和接口有什么区别" class="headerlink" title="4、抽象类和接口有什么区别"></a>4、抽象类和接口有什么区别</h4><ul><li><p>被abstract修饰的类即为抽象类，抽象类不能够创建实例对象。含有抽象方法的类必须定义为抽象类，但抽象类中的所有方法<strong>不必</strong>都是抽象的。抽象类中定义的抽象方法必须在具体的子类中实现，所以，没有抽象构造方法和抽象静态方法。</p></li><li><p>接口可以说成是抽象类的一种特例，接口中的所有方法都必须是抽象的。接口中的方法定义默认为public abstract类型，接口中的成员变量类型默认为public static final。</p><p>下面比较一下两者的区别：</p><ol><li>抽象类可以有构造方法，接口中不能有构造方法。</li><li>抽象类中可以有普通成员变量，接口中没有普通成员变量。</li><li>抽象类中可以包含非抽象的普通方法，接口中的所有方法必须都是抽象的，不能有非抽象的普通方法。</li><li>抽象类中的抽象方法可以是public、protected、default的，接口中的可以是public、private和default的。</li><li>抽象类中可以包含静态方法，接口中则不行。</li><li>抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意，但接口中定义的变量只能是public static final类型，并且默认即为public static final类型。</li><li>一个类可以实现多个接口，但只能继承一个抽象类</li></ol></li></ul><h4 id="5、super-getClass-方法调用"><a href="#5、super-getClass-方法调用" class="headerlink" title="5、super.getClass()方法调用"></a>5、super.getClass()方法调用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> <span class="keyword">extends</span> <span class="title class_">Date</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Test</span>().test();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="built_in">super</span>.getClass().getName());</span><br><span class="line">        System.out.println(getClass().getSuperclass().getName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个输出为Test，第二个输出才为Date。因为getClass()在Object中被定义为final，子类无法覆盖该方法，因此返回的都是当前运行的类的名称。</p><h4 id="6、final，finally，finalize的区别"><a href="#6、final，finally，finalize的区别" class="headerlink" title="6、final，finally，finalize的区别"></a>6、final，finally，finalize的区别</h4><ul><li>final用于声明属性、方法和类，分别表示属性不可变，方法不可覆盖，类不可继承。注意，内部类要访问局部变量的时候，局部变量必须定义为final，是为了解决方法内的局部变量和内部类的实例对象生存周期不一致的问题，同时防止内部类对其进行修改，导致数据不同步的问题。</li><li>finally是异常处理语句结构的一部分，总是执行。</li><li>finalize是Object的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等。JVM不保证此方法总被调用。此方法在jdk17中已被弃用。</li></ul><h4 id="7、sleep-和wait-有什么区别"><a href="#7、sleep-和wait-有什么区别" class="headerlink" title="7、sleep()和wait()有什么区别"></a>7、sleep()和wait()有什么区别</h4><ul><li>sleep()是线程类（Thread）的方法，导致此线程暂停执行指定时间，给执行机会给其他线程，但是监控状态依然保持，到时后会自动恢复。调用sleep不会释放对象锁。</li><li>wait()是Object类的方法，对此对象调用wait方法导致本线程放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象发出notify()或notifyAll()方法后本线程才进入对象锁定池准备获得对象锁进入运行状态。</li></ul><p>sleep就是正在执行的线程主动让出cpu，cpu去执行其他线程，在sleep指定的时间过后，cpu才会回到这个线程上继续往下执行，如果当前线程进入了同步锁，sleep方法并不会释放锁，即使当前线程使用sleep方法让出了cpu，但其他被同步锁挡住了的线程也无法得到执行。wait是指在一个已经进入了同步锁的线程内，让自己暂时让出同步锁，以便其他正在等待此锁的线程可以得到同步锁并运行，只有其他线程调用了notify方法（notify并不释放锁，只是告诉调用过wait方法的线程可以去参与获得锁的竞争了，但不是马上得到锁，因为锁还在别人手里，别人还没释放。如果notify方法后面的代码还有很多，需要这些代码执行完后才会释放锁），调用wait方法的线程就会解除wait状态和程序可以再次得到锁后继续向下运行。</p><h4 id="8、包装类型的缓存机制"><a href="#8、包装类型的缓存机制" class="headerlink" title="8、包装类型的缓存机制"></a>8、包装类型的缓存机制</h4><ul><li><p>Java 基本数据类型的包装类型的大部分都用到了缓存机制来提升性能。<code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 <strong>[-128，127]</strong> 的相应类型的缓存数据，<code>Character</code> 创建了数值在 <strong>[0,127]</strong> 范围的缓存数据，<code>Boolean</code> 直接返回 <code>True</code> or <code>False</code>。</p></li><li><p>如果超出对应范围仍然会去创建新的对象，缓存的范围区间的大小只是在性能和资源之间的权衡。</p><p>两种浮点数类型的包装类 <code>Float</code>,<code>Double</code> 并没有实现缓存机制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">40</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">40</span>);</span><br><span class="line">System.out.println(i1==i2);</span><br></pre></td></tr></table></figure><p>上述代码将返回false。因为<code>Integer i1=40</code> 这一行代码会发生装箱，也就是说这行代码等价于 <code>Integer i1=Integer.valueOf(40)</code> 。因此，<code>i1</code> 直接使用的是缓存中的对象。而<code>Integer i2 = new Integer(40)</code> 会直接创建新的对象。</p></li></ul><h4 id="9、深拷贝与浅拷贝"><a href="#9、深拷贝与浅拷贝" class="headerlink" title="9、深拷贝与浅拷贝"></a>9、深拷贝与浅拷贝</h4><ul><li><p>浅拷贝：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。</p></li><li><p>深拷贝：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。</p></li><li><p>引用拷贝：引用拷贝就是两个不同的引用指向同一个对象。</p><p><img src="https://img-1309553126.cos.ap-beijing.myqcloud.com/blog_imgs/image-20230407215648574.webp" alt="image-20230407215648574"></p></li></ul><h4 id="10、Exception和Error"><a href="#10、Exception和Error" class="headerlink" title="10、Exception和Error"></a>10、Exception和Error</h4><p>在 Java 中，所有的异常都有一个共同的祖先 <code>Throwable</code> 。<code>Throwable</code> 类有两个重要的子类:</p><ul><li><strong><code>Exception</code></strong> :程序本身可以处理的异常，可以通过 <code>catch</code> 来进行捕获。<code>Exception</code> 又可以分为 Checked Exception (受检查异常，必须处理) 和 Unchecked Exception (不受检查异常，可以不处理)。</li><li><strong><code>Error</code></strong> ：<code>Error</code> 属于程序无法处理的错误 ，不建议通过<code>catch</code>捕获 。例如 Java 虚拟机运行错误（<code>Virtual MachineError</code>）、虚拟机内存不够错误(<code>OutOfMemoryError</code>)、类定义错误（<code>NoClassDefFoundError</code>）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。</li></ul><p>Checked Exception 和 Unchecked Exception 有什么区别</p><ul><li><p>Checked Exception 即受检查异常 ，Java 代码在编译过程中，如果受检查异常没有被 <code>catch</code>或者<code>throws</code> 关键字处理的话，就没办法通过编译。除了<code>RuntimeException</code>及其子类以外，其他的<code>Exception</code>类及其子类都属于受检查异常 。常见的受检查异常有： IO 相关的异常、<code>ClassNotFoundException</code> 、<code>SQLException</code>等。</p></li><li><p>Unchecked Exception 即不受检查异常 ，Java 代码在编译过程中 ，我们即使不处理不受检查异常也可以正常通过编译。</p><p><code>RuntimeException</code> 及其子类都统称为非受检查异常，常见的有：</p><ul><li><code>NullPointerException</code>(空指针错误)</li><li><code>IllegalArgumentException</code>(参数错误比如方法入参类型错误)</li><li><code>NumberFormatException</code>（字符串转换为数字格式错误，<code>IllegalArgumentException</code>的子类）</li><li><code>ArrayIndexOutOfBoundsException</code>（数组越界错误）</li><li><code>ClassCastException</code>（类型转换错误）</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;1、final关键字&quot;&gt;&lt;a href=&quot;#1、final关键字&quot; class=&quot;headerlink&quot; title=&quot;1、final关键字&quot;&gt;&lt;/a&gt;1、final关键字&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;final声明的变量&lt;/p&gt;
&lt;p&gt;使用final关键字修</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    
    <category term="Java基础" scheme="http://example.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>网络基础</title>
    <link href="http://example.com/2023/03/04/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/2023/03/04/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/</id>
    <published>2023-03-04T12:09:54.000Z</published>
    <updated>2023-03-21T10:33:32.034Z</updated>
    
    
    
    
    <category term="计算机网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>MySQL详解</title>
    <link href="http://example.com/2023/02/20/MySQL%E8%AF%A6%E8%A7%A3/"/>
    <id>http://example.com/2023/02/20/MySQL%E8%AF%A6%E8%A7%A3/</id>
    <published>2023-02-20T03:00:18.000Z</published>
    <updated>2023-03-21T10:33:36.375Z</updated>
    
    
    
    
    <category term="数据库" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="mysql" scheme="http://example.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer专题</title>
    <link href="http://example.com/2023/02/20/%E5%89%91%E6%8C%87Offer/"/>
    <id>http://example.com/2023/02/20/%E5%89%91%E6%8C%87Offer/</id>
    <published>2023-02-20T03:00:18.000Z</published>
    <updated>2023-03-26T11:47:44.149Z</updated>
    
    <content type="html"><![CDATA[<h1 id="剑指Offer专题"><a href="#剑指Offer专题" class="headerlink" title="剑指Offer专题"></a>剑指Offer专题</h1><h4 id="剑指Offer03-数组中重复的数字"><a href="#剑指Offer03-数组中重复的数字" class="headerlink" title="剑指Offer03.数组中重复的数字"></a><a href="https://leetcode.cn/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/description/">剑指Offer03.数组中重复的数字</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.利用数组或者Set进行判断</span></span><br><span class="line"><span class="comment">//时间复杂度O(n),空间复杂度O(n)</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findRepeatNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">       <span class="type">int</span>[] map=<span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> num:nums)&#123;</span><br><span class="line">           <span class="keyword">if</span>(map[num]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">               <span class="keyword">return</span> num;</span><br><span class="line">           &#125;</span><br><span class="line">           map[num]++;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findRepeatNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">       Set&lt;Integer&gt; set=<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> num:nums)&#123;</span><br><span class="line">           <span class="keyword">if</span>(set.contains(num))&#123;</span><br><span class="line">               <span class="keyword">return</span> num;</span><br><span class="line">           &#125;</span><br><span class="line">           set.add(num);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2.由于给定的数值都是小于nums.length的，所以可以进一步减少空间复杂度，实现原地交换</span></span><br><span class="line"><span class="comment">//时间复杂度O(n)，空间复杂度O(1)</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findRepeatNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;)&#123;</span><br><span class="line">           <span class="comment">//如果当前元素已在其相同下标的位置，则处理下一个元素</span></span><br><span class="line">           <span class="keyword">if</span>(nums[i]==i)&#123;</span><br><span class="line">               i++;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//如果当前元素所在的下标位置已经有相同的数字，则说明该元素重复了</span></span><br><span class="line">           <span class="keyword">if</span>(nums[i]==nums[nums[i]])&#123;</span><br><span class="line">               <span class="keyword">return</span> nums[i];</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//否则就把当前元素放到指定下标位置，准备处理那个换过来的元素</span></span><br><span class="line">           <span class="type">int</span> t=nums[nums[i]];</span><br><span class="line">           nums[nums[i]]=nums[i];</span><br><span class="line">           nums[i]=t;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-04-二维数组中的查找"><a href="#剑指-Offer-04-二维数组中的查找" class="headerlink" title="剑指 Offer 04. 二维数组中的查找"></a><a href="https://leetcode.cn/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/">剑指 Offer 04. 二维数组中的查找</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.利用二分查找，因为每一行都有序，所以对每一行都进行一次二分查找即可</span></span><br><span class="line"><span class="comment">//时间复杂度O(nlog(m))，空间复杂度O(1)</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">findNumberIn2DArray</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span>[] row:matrix)&#123;</span><br><span class="line">           <span class="keyword">if</span>(binarySearch(row,target))&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] row,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">       <span class="type">int</span> left=<span class="number">0</span>,right=row.length-<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">           <span class="type">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">           <span class="keyword">if</span>(target==row[mid])&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span>(target&gt;row[mid])&#123;</span><br><span class="line">               left=mid+<span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span>&#123;</span><br><span class="line">               right=mid-<span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2.利用方法1的二分查找可以发现，只利用了行有序，没有用上列有序。</span></span><br><span class="line"><span class="comment">//从矩阵的右上角开始遍历，可以发现左边元素都比自己小，右边元素都比自己大，可以对这一性质加以利用。</span></span><br><span class="line">   <span class="comment">//如果当前元素大于target，则可以排除当前列，因为该列下方元素都比它大</span></span><br><span class="line">   <span class="comment">//如果当前元素小于target，则可以排除当前行，因为该行左边元素都比它小</span></span><br><span class="line">   <span class="comment">//时间复杂度O(m+n)，空间复杂度O(1)</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">findNumberIn2DArray</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">       <span class="type">int</span> m=matrix.length;</span><br><span class="line">       <span class="keyword">if</span>(m==<span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">int</span> n=matrix[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">       <span class="type">int</span> i=<span class="number">0</span>,j=n-<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">while</span>(i&lt;m&amp;&amp;j&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">if</span>(target==matrix[i][j])&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span>(target&lt;matrix[i][j])&#123;</span><br><span class="line">               j--;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span>&#123;</span><br><span class="line">               i++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-05-替换空格"><a href="#剑指-Offer-05-替换空格" class="headerlink" title="剑指 Offer 05. 替换空格"></a><a href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof/description/">剑指 Offer 05. 替换空格</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//简单模拟即可    </span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">replaceSpace</span><span class="params">(String s)</span> &#123;</span><br><span class="line">       <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">char</span> c:s.toCharArray())&#123;</span><br><span class="line">           <span class="keyword">if</span>(c==<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">               sb.append(<span class="string">&quot;%20&quot;</span>);</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               sb.append(c);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> sb.toString();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-06-从尾到头打印链表"><a href="#剑指-Offer-06-从尾到头打印链表" class="headerlink" title="剑指 Offer 06. 从尾到头打印链表"></a><a href="https://leetcode.cn/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/description/">剑指 Offer 06. 从尾到头打印链表</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//利用递归的性质，从数组最深处保存</span></span><br><span class="line"><span class="comment">//时间复杂度O(n),空间复杂度O(n)</span></span><br><span class="line">   <span class="type">int</span>[] ans;</span><br><span class="line">   <span class="type">int</span> len=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">       <span class="keyword">if</span>(head==<span class="literal">null</span>)&#123;</span><br><span class="line">           ans=<span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span>&#123;</span><br><span class="line">           len++;</span><br><span class="line">           reversePrint(head.next);</span><br><span class="line">           ans[ans.length-len]=head.val;</span><br><span class="line">           len--;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> ans;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为了节省递归导致的栈空间，可以使用最原始的方法，计算长度，然后直接存储</span></span><br><span class="line"><span class="comment">//时间复杂度O(n),空间复杂度O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">       ListNode p=head;</span><br><span class="line">       <span class="type">int</span> len=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span>(p!=<span class="literal">null</span>)&#123;</span><br><span class="line">           len++;</span><br><span class="line">           p=p.next;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       p=head;</span><br><span class="line">       <span class="type">int</span>[] ans=<span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len;++i)&#123;</span><br><span class="line">           ans[len-i]=p.val;</span><br><span class="line">           p=p.next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> ans;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-07-重建二叉树"><a href="#剑指-Offer-07-重建二叉树" class="headerlink" title="剑指 Offer 07. 重建二叉树"></a><a href="https://leetcode.cn/problems/zhong-jian-er-cha-shu-lcof/">剑指 Offer 07. 重建二叉树</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//利用先序遍历找到根节点，然后利用中序遍历确定其左子树有哪些节点，右子树有哪些节点</span></span><br><span class="line"><span class="comment">//难点在于在构造右子树时，根节点的下标需要根据左子树的节点个数来计算</span></span><br><span class="line"><span class="comment">//时间复杂度O(n),空间复杂度O(n)</span></span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> createNode(preorder,inorder,<span class="number">0</span>,<span class="number">0</span>,preorder.length);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> TreeNode <span class="title function_">createNode</span><span class="params">(<span class="type">int</span>[] preorder,<span class="type">int</span>[] inorder,<span class="type">int</span> rootidx,</span></span><br><span class="line"><span class="params">                              <span class="type">int</span> left,<span class="type">int</span> right)</span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(left&gt;=right)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">int</span> rootVal=preorder[rootidx];</span><br><span class="line">       TreeNode root=<span class="keyword">new</span> <span class="title class_">TreeNode</span>(rootVal);</span><br><span class="line">       <span class="type">int</span> i;</span><br><span class="line">       <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;inorder.length;++i)&#123;</span><br><span class="line">           <span class="keyword">if</span>(inorder[i]==rootVal)&#123;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       root.left=createNode(preorder,inorder,rootidx+<span class="number">1</span>,left,i);</span><br><span class="line">       root.right=createNode(preorder,inorder,rootidx+<span class="number">1</span>+i-left,i+<span class="number">1</span>,right);</span><br><span class="line">       <span class="keyword">return</span> root;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-09-用两个栈实现队列"><a href="#剑指-Offer-09-用两个栈实现队列" class="headerlink" title="剑指 Offer 09. 用两个栈实现队列"></a><a href="https://leetcode.cn/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/description/">剑指 Offer 09. 用两个栈实现队列</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造两个栈，分别为in和out，这样在队尾插入元素时，直接放入in中</span></span><br><span class="line"><span class="comment">//在队头删除元素时，先判断out栈是否有元素，若有则直接弹出，若没有，则判断in栈中是否有元素</span></span><br><span class="line"><span class="comment">//若in栈中有，则全部放入out栈中，并弹出out栈顶，否则返回-1</span></span><br><span class="line"><span class="comment">//时间复杂度O(n),空间复杂度O(n)</span></span><br><span class="line">   <span class="keyword">class</span> <span class="title class_">CQueue</span> &#123;</span><br><span class="line"></span><br><span class="line">       Stack&lt;Integer&gt; in;</span><br><span class="line">       Stack&lt;Integer&gt; out;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">public</span> <span class="title function_">CQueue</span><span class="params">()</span> &#123;</span><br><span class="line">           in=<span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">           out=<span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">appendTail</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">           in.push(value);</span><br><span class="line">       &#125;   </span><br><span class="line"></span><br><span class="line">       <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">deleteHead</span><span class="params">()</span> &#123;</span><br><span class="line">           <span class="keyword">if</span>(out.isEmpty())&#123;</span><br><span class="line">               <span class="keyword">if</span>(in.isEmpty())&#123;</span><br><span class="line">                   <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">else</span>&#123;</span><br><span class="line">                   <span class="keyword">while</span>(!in.isEmpty())&#123;</span><br><span class="line">                       out.push(in.pop());</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">return</span> out.pop();</span><br><span class="line">               &#125; </span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> out.pop();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-10-I-斐波那契数列"><a href="#剑指-Offer-10-I-斐波那契数列" class="headerlink" title="剑指 Offer 10- I. 斐波那契数列"></a><a href="https://leetcode.cn/problems/fei-bo-na-qi-shu-lie-lcof/">剑指 Offer 10- I. 斐波那契数列</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//最简单的动态规划</span></span><br><span class="line"><span class="comment">//转移方程为 dp[i]=dp[i-1]+dp[i-2]</span></span><br><span class="line"><span class="comment">//base case为dp[0]=0,dp[1]=1</span></span><br><span class="line"><span class="comment">//由于状态转移只与前两个状态有关，因此可以使用两个临时变量来代替dp数组</span></span><br><span class="line"><span class="comment">//时间复杂度O(n),空间复杂度O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span>(n&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> n;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="type">int</span> pre_1=<span class="number">1</span>,pre_2=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;++i)&#123;</span><br><span class="line">           <span class="type">int</span> t=(pre_1+pre_2)%<span class="number">1000000007</span>;</span><br><span class="line">           pre_2=pre_1;</span><br><span class="line">           pre_1=t;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> pre_1;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-10-II-青蛙跳台阶问题"><a href="#剑指-Offer-10-II-青蛙跳台阶问题" class="headerlink" title="剑指 Offer 10- II. 青蛙跳台阶问题"></a><a href="https://leetcode.cn/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/">剑指 Offer 10- II. 青蛙跳台阶问题</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//最简单的动态规划</span></span><br><span class="line"><span class="comment">//转移方程为 dp[i]=dp[i-1]+dp[i-2]</span></span><br><span class="line"><span class="comment">//base case为dp[0]=1,dp[1]=1</span></span><br><span class="line"><span class="comment">//由于状态转移只与前两个状态有关，因此可以使用两个临时变量来代替dp数组</span></span><br><span class="line"><span class="comment">//时间复杂度O(n),空间复杂度O(1)</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numWays</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span>(n&lt;<span class="number">2</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="type">int</span> pre_1=<span class="number">1</span>,pre_2=<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;++i)&#123;</span><br><span class="line">           <span class="type">int</span> t=(pre_1+pre_2)%<span class="number">1000000007</span>;</span><br><span class="line">           pre_2=pre_1;</span><br><span class="line">           pre_1=t;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> pre_1;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-11-旋转数组的最小数字"><a href="#剑指-Offer-11-旋转数组的最小数字" class="headerlink" title="剑指 Offer 11. 旋转数组的最小数字"></a><a href="https://leetcode.cn/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/description/">剑指 Offer 11. 旋转数组的最小数字</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//二分查找</span></span><br><span class="line"><span class="comment">//当最右边元素大于中间元素时，最小值只可能在中间或者左边，故mid=right</span></span><br><span class="line"><span class="comment">//而当最右边元素小于中间元素时，最小值只有可能在右边，故left=mid+1</span></span><br><span class="line"><span class="comment">//本题难点在于存在重复元素，由于本题数字有序排列，因此去重起来比较简单</span></span><br><span class="line"><span class="comment">//当遇到重复元素时，把最右边的那一个元素去掉，再重新查找即可</span></span><br><span class="line"><span class="comment">//时间复杂度O(logn),最坏O(n),空间复杂度O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minArray</span><span class="params">(<span class="type">int</span>[] numbers)</span> &#123;</span><br><span class="line">       <span class="type">int</span> left=<span class="number">0</span>,right=numbers.length-<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">           <span class="type">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">           <span class="keyword">if</span>(numbers[mid]&lt;numbers[right])&#123;</span><br><span class="line">               right=mid;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span>(numbers[mid]&gt;numbers[right])&#123;</span><br><span class="line">               left=mid+<span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span>&#123;</span><br><span class="line">               right--;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> numbers[left];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-12-矩阵中的路径"><a href="#剑指-Offer-12-矩阵中的路径" class="headerlink" title="剑指 Offer 12. 矩阵中的路径"></a><a href="https://leetcode.cn/problems/ju-zhen-zhong-de-lu-jing-lcof/description/">剑指 Offer 12. 矩阵中的路径</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//简单的dfs搜索</span></span><br><span class="line"><span class="comment">//值得注意的是，可以在board上直接修改，而不用visited数组</span></span><br><span class="line"><span class="comment">//时间复杂度O(mn·3^L),空间复杂度O(L),L为单词长度</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">exist</span><span class="params">(<span class="type">char</span>[][] board, String word)</span> &#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;++i)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;++j)&#123;</span><br><span class="line">               <span class="keyword">if</span>(dfs(board,i,j,<span class="number">0</span>,word))&#123;</span><br><span class="line">                   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] board, <span class="type">int</span> i,<span class="type">int</span> j,<span class="type">int</span> loc,String word)</span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(loc==word.length())&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(i&lt;<span class="number">0</span>||i&gt;=board.length||j&lt;<span class="number">0</span>||j&gt;=board[<span class="number">0</span>].length||</span><br><span class="line">          board[i][j]==<span class="string">&#x27;0&#x27;</span>||board[i][j]!=word.charAt(loc)) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       board[i][j]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">       <span class="type">boolean</span> ans=dfs(board,i-<span class="number">1</span>,j,loc+<span class="number">1</span>,word)||</span><br><span class="line">           dfs(board,i+<span class="number">1</span>,j,loc+<span class="number">1</span>,word)||</span><br><span class="line">           dfs(board,i,j-<span class="number">1</span>,loc+<span class="number">1</span>,word)||</span><br><span class="line">           dfs(board,i,j+<span class="number">1</span>,loc+<span class="number">1</span>,word);</span><br><span class="line">       board[i][j]=word.charAt(loc);</span><br><span class="line">       <span class="keyword">return</span> ans;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-14-I-剪绳子"><a href="#剑指-Offer-14-I-剪绳子" class="headerlink" title="剑指 Offer 14- I. 剪绳子"></a><a href="https://leetcode.cn/problems/jian-sheng-zi-lcof/description/">剑指 Offer 14- I. 剪绳子</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//1.首先确定状态转移，dp[i]表示将长度为i的绳子剪成m段后，它们的最大乘积</span></span><br><span class="line"><span class="comment">//对于长度为i的绳子来说，有两种选择</span></span><br><span class="line"><span class="comment">//1).将绳子分为两段，j和（i-j），这样乘积为i*（i-j）</span></span><br><span class="line"><span class="comment">//2).将绳子分为多段，第一段为j，后面的继续分，这样乘积是j*dp[i-j]</span></span><br><span class="line"><span class="comment">//然后确定base case，可以知道绳子长度为1时，不可分，故dp[1]=0</span></span><br><span class="line"><span class="comment">//对于长度为i的绳子，需要知道怎么切，切多长时，乘积最大，因此需要遍历j从1到i-1</span></span><br><span class="line"><span class="comment">//即第一段长为（i-j），后面比较只切为两段的乘积大，还是再切的乘积大</span></span><br><span class="line"><span class="comment">//时间复杂度O(n^2),空间复杂度O(n)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">cuttingRope</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">       <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;i;++j)&#123;</span><br><span class="line">               <span class="type">int</span> t=Math.max(j*(i-j),dp[j]*(i-j));</span><br><span class="line">               dp[i]=Math.max(dp[i],t);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> dp[n];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2.利用数学知识</span></span><br><span class="line"><span class="comment">//对于长度为2的绳子，只能对半切，即2=1+1&gt;1*1，因此长度为2的绳子不适合切分</span></span><br><span class="line"><span class="comment">//对于长度为3的绳子，只能切分为1+2,即3=1+2&gt;1*2，因此长度为3的绳子也不适合切分</span></span><br><span class="line"><span class="comment">//对于长度为4的绳子，可以切分为1+3和2+2，即4=1+3&gt;1*3,4=2+2=2*2,因此长度为4的适合切分为2+2</span></span><br><span class="line"><span class="comment">//对于长度为5以上的绳子，总可以切分为乘积大于其本身的两段或几段</span></span><br><span class="line"><span class="comment">//因此，尽量将绳子切割为长度为3的小段，这样乘积更大</span></span><br><span class="line"><span class="comment">//时间复杂度O(n),空间复杂度O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">cuttingRope</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">       <span class="comment">//当长度小于等于3时，不适合切割</span></span><br><span class="line">       <span class="keyword">if</span>(n&lt;=<span class="number">3</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> n-<span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//求出绳子能分为几个长度为3的段，以及长度余多少</span></span><br><span class="line">       <span class="type">int</span> a=n/<span class="number">3</span>,b=n%<span class="number">3</span>;</span><br><span class="line">       <span class="comment">//如果长度余0，则说明能整分</span></span><br><span class="line">       <span class="keyword">if</span>(b==<span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> (<span class="type">int</span>)Math.pow(<span class="number">3</span>,a);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//如果长度余1，此时如果直接乘1结果不是最大，需要拿出一个3，使其变成4，这样乘积更大</span></span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span>(b==<span class="number">1</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> (<span class="type">int</span>)Math.pow(<span class="number">3</span>,a-<span class="number">1</span>)*<span class="number">4</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//如果余2则直接相乘</span></span><br><span class="line">       <span class="keyword">else</span>&#123;</span><br><span class="line">           <span class="keyword">return</span> (<span class="type">int</span>)Math.pow(<span class="number">3</span>,a)*<span class="number">2</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-14-II-剪绳子-II"><a href="#剑指-Offer-14-II-剪绳子-II" class="headerlink" title="剑指 Offer 14- II. 剪绳子 II"></a><a href="https://leetcode.cn/problems/jian-sheng-zi-ii-lcof/">剑指 Offer 14- II. 剪绳子 II</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//与上题相似，但dp方法需要改进后才能使用，主要是取余后的数字进行比较造成的</span></span><br><span class="line"><span class="comment">//因此主要还是使用数学方法</span></span><br><span class="line"><span class="comment">//时间复杂度O(n),空间复杂度O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">cuttingRope</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span>(n&lt;<span class="number">4</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> n-<span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">long</span> ans=<span class="number">1L</span>;</span><br><span class="line">       <span class="keyword">while</span>(n&gt;<span class="number">4</span>)&#123;</span><br><span class="line">           ans=ans*<span class="number">3</span>%<span class="number">1000000007</span>;</span><br><span class="line">           n-=<span class="number">3</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> (<span class="type">int</span>)(ans*n%<span class="number">1000000007</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-15-二进制中1的个数"><a href="#剑指-Offer-15-二进制中1的个数" class="headerlink" title="剑指 Offer 15. 二进制中1的个数"></a><a href="https://leetcode.cn/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/">剑指 Offer 15. 二进制中1的个数</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//使用位运算</span></span><br><span class="line"><span class="comment">//n&amp;1主要是判断当前最右边是不是1</span></span><br><span class="line"><span class="comment">//n&gt;&gt;1右移准备判断下一位</span></span><br><span class="line"><span class="comment">//时间复杂度固定,空间复杂度O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hammingWeight</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">       <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">       <span class="type">int</span> k=<span class="number">32</span>;</span><br><span class="line">       <span class="keyword">while</span>(k&gt;<span class="number">0</span>)&#123;</span><br><span class="line">           <span class="type">int</span> t=n&amp;<span class="number">1</span>;</span><br><span class="line">           <span class="keyword">if</span>(t==<span class="number">1</span>)&#123;</span><br><span class="line">               ans++;</span><br><span class="line">           &#125;</span><br><span class="line">           n=n&gt;&gt;<span class="number">1</span>;</span><br><span class="line">           k--;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> ans;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-16-数值的整数次方"><a href="#剑指-Offer-16-数值的整数次方" class="headerlink" title="剑指 Offer 16. 数值的整数次方"></a><a href="https://leetcode.cn/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/description/">剑指 Offer 16. 数值的整数次方</a></h4><p>利用二分快速幂的方法实现。首先，对于n&lt;0的情况先进行判断，并修改x和n，然后再进行处理。<br>快速幂就是将$$x^n$$分解为$$(x^2)^{n/2}$$，然后再分解为$$(x^4)^{n/4}$$，直到上标为0。但是每次在二分的时候需要注意，当n为奇数的时候，没有办法整除，会多出一项，因此在结果上需要多乘一次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//时间复杂度O(logn),空间复杂度O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span>(x==<span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">double</span> ans=<span class="number">1.0</span>;</span><br><span class="line">       <span class="comment">//为了处理-2^31</span></span><br><span class="line">       <span class="type">long</span> t=n;</span><br><span class="line">       <span class="keyword">if</span>(t&lt;<span class="number">0</span>)&#123;</span><br><span class="line">           x=<span class="number">1</span>/x;</span><br><span class="line">           t=-t;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">while</span>(t&gt;<span class="number">0</span>)&#123;</span><br><span class="line">           <span class="comment">//等价于t%2==1</span></span><br><span class="line">           <span class="keyword">if</span>((t&amp;<span class="number">1</span>)==<span class="number">1</span>)&#123;</span><br><span class="line">               ans*=x;</span><br><span class="line">           &#125;</span><br><span class="line">           x*=x;</span><br><span class="line">           t&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> ans;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-17-打印从1到最大的n位数"><a href="#剑指-Offer-17-打印从1到最大的n位数" class="headerlink" title="剑指 Offer 17. 打印从1到最大的n位数"></a><a href="https://leetcode.cn/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/description/">剑指 Offer 17. 打印从1到最大的n位数</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//简单模拟</span></span><br><span class="line"><span class="comment">//1位正数有9个</span></span><br><span class="line"><span class="comment">//2位正数有90个</span></span><br><span class="line"><span class="comment">//   ……</span></span><br><span class="line"><span class="comment">//时间复杂度O(n),空间复杂度O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] printNumbers(<span class="type">int</span> n) &#123;</span><br><span class="line">       <span class="type">int</span> total=(<span class="type">int</span>)Math.pow(<span class="number">10</span>,n)-<span class="number">1</span>;</span><br><span class="line">       <span class="type">int</span>[] ans=<span class="keyword">new</span> <span class="title class_">int</span>[total];</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=total;i++)&#123;</span><br><span class="line">           ans[i-<span class="number">1</span>]=i;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> ans;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-18-删除链表的节点"><a href="#剑指-Offer-18-删除链表的节点" class="headerlink" title="剑指 Offer 18. 删除链表的节点"></a><a href="https://leetcode.cn/problems/shan-chu-lian-biao-de-jie-dian-lcof/description/">剑指 Offer 18. 删除链表的节点</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//遍历链表并删除</span></span><br><span class="line"><span class="comment">//时间复杂度O(n),空间复杂度O(1)</span></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">deleteNode</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">       ListNode dummy=<span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">       dummy.next=head;</span><br><span class="line">       ListNode pre=dummy,cur=head;</span><br><span class="line">       <span class="keyword">while</span>(cur!=<span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="keyword">if</span>(cur.val==val)&#123;</span><br><span class="line">               pre.next=cur.next;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span>&#123;</span><br><span class="line">               pre=cur;</span><br><span class="line">               cur=cur.next;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> dummy.next;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-20-表示数值的字符串"><a href="#剑指-Offer-20-表示数值的字符串" class="headerlink" title="剑指 Offer 20. 表示数值的字符串"></a><a href="https://leetcode.cn/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/description/">剑指 Offer 20. 表示数值的字符串</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//字符串模拟</span></span><br><span class="line"><span class="comment">//如果需要对数字、E和.进行记录，然后根据非法情况进行判别</span></span><br><span class="line"><span class="comment">//具体看代码注释</span></span><br><span class="line"><span class="comment">//时间复杂度O(n),空间复杂度O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isNumber</span><span class="params">(String s)</span> &#123;</span><br><span class="line">       <span class="type">boolean</span> isNum=<span class="literal">false</span>,hasE=<span class="literal">false</span>,hasDot=<span class="literal">false</span>;</span><br><span class="line">       <span class="comment">//需要去除字符串前后的空格</span></span><br><span class="line">       s=s.trim();</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.length();++i)&#123;</span><br><span class="line">           <span class="type">char</span> cur=s.charAt(i);</span><br><span class="line">           <span class="comment">//若为数字则数字标志置true</span></span><br><span class="line">           <span class="keyword">if</span>(cur&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;cur&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">               isNum=<span class="literal">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//若为.则需要进一步判断，如果前面有.或者E则都非法</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span>(cur==<span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">               <span class="keyword">if</span>(hasDot||hasE)&#123;</span><br><span class="line">                   <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               hasDot=<span class="literal">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//若为E，则需要判断，E前面必须有数字并且只能有一个E</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span>(cur==<span class="string">&#x27;E&#x27;</span>||cur==<span class="string">&#x27;e&#x27;</span>)&#123;</span><br><span class="line">               <span class="keyword">if</span>(!isNum||hasE)&#123;</span><br><span class="line">                   <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               hasE=<span class="literal">true</span>;</span><br><span class="line">               isNum=<span class="literal">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//若为+和-，这两个只能在串头和E的后面</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span>(cur==<span class="string">&#x27;+&#x27;</span>||cur==<span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">               <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;!(s.charAt(i-<span class="number">1</span>)==<span class="string">&#x27;E&#x27;</span>||s.charAt(i-<span class="number">1</span>)==<span class="string">&#x27;e&#x27;</span>))&#123;</span><br><span class="line">                   <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//其他情况都为false</span></span><br><span class="line">           <span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> isNum;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-21-调整数组顺序使奇数位于偶数前面"><a href="#剑指-Offer-21-调整数组顺序使奇数位于偶数前面" class="headerlink" title="剑指 Offer 21. 调整数组顺序使奇数位于偶数前面"></a><a href="https://leetcode.cn/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/description/">剑指 Offer 21. 调整数组顺序使奇数位于偶数前面</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//经典双指针（前后指针）</span></span><br><span class="line"><span class="comment">//时间复杂度O(n),空间复杂度O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] exchange(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">       <span class="type">int</span> left=<span class="number">0</span>,right=nums.length-<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">           <span class="keyword">while</span>(left&lt;right&amp;&amp;(nums[left]&amp;<span class="number">1</span>)==<span class="number">1</span>)&#123;</span><br><span class="line">               left++;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">while</span>(left&lt;right&amp;&amp;(nums[right]&amp;<span class="number">1</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">               right--;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">               <span class="type">int</span> t=nums[left];</span><br><span class="line">               nums[left]=nums[right];</span><br><span class="line">               nums[right]=t;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> nums;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-68-I-二叉搜索树的最近公共祖先"><a href="#剑指-Offer-68-I-二叉搜索树的最近公共祖先" class="headerlink" title="剑指 Offer 68 - I. 二叉搜索树的最近公共祖先"></a><a href="https://leetcode.cn/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/description/">剑指 Offer 68 - I. 二叉搜索树的最近公共祖先</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//由于二叉搜索树的特性,当p，q的值都小于root的值时，需要去左子树查询</span></span><br><span class="line"><span class="comment">//当p，q的值都大于root的值时，需要去右子树查询</span></span><br><span class="line"><span class="comment">//否则其他情况直接返回root：</span></span><br><span class="line"><span class="comment">//1.p,q一大一小，位于root两侧</span></span><br><span class="line"><span class="comment">//  2.p,q中有一个等于root</span></span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(root.val&gt;p.val&amp;&amp;root.val&gt;q.val)&#123;</span><br><span class="line">           <span class="keyword">return</span> lowestCommonAncestor(root.left,p,q);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span>(root.val&lt;p.val&amp;&amp;root.val&lt;q.val)&#123;</span><br><span class="line">           <span class="keyword">return</span> lowestCommonAncestor(root.right,p,q);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> root;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-68-II-二叉树的最近公共祖先"><a href="#剑指-Offer-68-II-二叉树的最近公共祖先" class="headerlink" title="剑指 Offer 68 - II. 二叉树的最近公共祖先"></a><a href="https://leetcode.cn/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/description/">剑指 Offer 68 - II. 二叉树的最近公共祖先</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//该树不是二叉搜索树，为普通的树，因此不能利用结点的值进行判断</span></span><br><span class="line"><span class="comment">//但思路和上一题类似</span></span><br><span class="line"><span class="comment">//1.如果p，q有一个是根，则直接返回根节点</span></span><br><span class="line"><span class="comment">//2.分别在左右子树里查找p，q，若左右子树返回不为空，则说明p，q在不同的子树，则返回根</span></span><br><span class="line"><span class="comment">//3.若左子树为空，则去右子树查找，继续在右子树进行1操作，右子树为空同理</span></span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(root==p||root==q)&#123;</span><br><span class="line">           <span class="keyword">return</span> root;</span><br><span class="line">       &#125;</span><br><span class="line">       TreeNode l=lowestCommonAncestor(root.left,p,q);</span><br><span class="line">       TreeNode r=lowestCommonAncestor(root.right,p,q);</span><br><span class="line">       <span class="keyword">if</span>(l!=<span class="literal">null</span>&amp;&amp;r!=<span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> root;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span>(l==<span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> r;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span>&#123;</span><br><span class="line">           <span class="keyword">return</span> l;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;剑指Offer专题&quot;&gt;&lt;a href=&quot;#剑指Offer专题&quot; class=&quot;headerlink&quot; title=&quot;剑指Offer专题&quot;&gt;&lt;/a&gt;剑指Offer专题&lt;/h1&gt;&lt;h4 id=&quot;剑指Offer03-数组中重复的数字&quot;&gt;&lt;a href=&quot;#剑指Offer</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="剑指Offer" scheme="http://example.com/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>TCP协议详解</title>
    <link href="http://example.com/2023/02/20/tcp%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/"/>
    <id>http://example.com/2023/02/20/tcp%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/</id>
    <published>2023-02-20T03:00:18.000Z</published>
    <updated>2023-04-06T11:24:12.521Z</updated>
    
    
    
    
    <category term="计算机网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="tcp" scheme="http://example.com/tags/tcp/"/>
    
  </entry>
  
  <entry>
    <title>操作系统基础</title>
    <link href="http://example.com/2023/02/20/%E7%BA%BF%E7%A8%8B%E8%AF%A6%E8%A7%A3/"/>
    <id>http://example.com/2023/02/20/%E7%BA%BF%E7%A8%8B%E8%AF%A6%E8%A7%A3/</id>
    <published>2023-02-20T03:00:18.000Z</published>
    <updated>2023-04-08T06:04:12.965Z</updated>
    
    
    
    
    <category term="操作系统" scheme="http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="thread" scheme="http://example.com/tags/thread/"/>
    
  </entry>
  
</feed>
